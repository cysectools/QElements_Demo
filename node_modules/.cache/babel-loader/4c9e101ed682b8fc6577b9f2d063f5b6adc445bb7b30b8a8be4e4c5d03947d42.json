{"ast":null,"code":"export class QElementResponsiveManager {\n  constructor(config) {\n    this._mediaQueries = new Map();\n    this._listeners = new Map();\n    this._config = {\n      breakpoints: {\n        sm: '640px',\n        md: '768px',\n        lg: '1024px',\n        xl: '1280px',\n        '2xl': '1536px'\n      },\n      defaultBreakpoint: 'md',\n      ...config\n    };\n    this._initializeMediaQueries();\n  }\n  _initializeMediaQueries() {\n    Object.entries(this._config.breakpoints).forEach(([breakpoint, value]) => {\n      const mediaQuery = window.matchMedia(`(min-width: ${value})`);\n      this._mediaQueries.set(breakpoint, mediaQuery);\n    });\n  }\n  // Get the current active breakpoint\n  getCurrentBreakpoint() {\n    const sortedBreakpoints = Object.entries(this._config.breakpoints).sort(([, a], [, b]) => parseInt(a) - parseInt(b)).reverse();\n    for (const [breakpoint, value] of sortedBreakpoints) {\n      const mediaQuery = this._mediaQueries.get(breakpoint);\n      if (mediaQuery && mediaQuery.matches) {\n        return breakpoint;\n      }\n    }\n    return 'sm'; // Default to smallest breakpoint\n  }\n  // Check if a breakpoint is currently active\n  isBreakpointActive(breakpoint) {\n    const mediaQuery = this._mediaQueries.get(breakpoint);\n    return mediaQuery ? mediaQuery.matches : false;\n  }\n  // Get responsive styles for the current breakpoint\n  getResponsiveStyles(style) {\n    const currentBreakpoint = this.getCurrentBreakpoint();\n    const responsiveStyle = {\n      ...style\n    };\n    // Apply media query styles\n    if (style['@media']) {\n      const mediaStyles = style['@media'];\n      // Apply styles for the current breakpoint and smaller ones\n      const sortedBreakpoints = Object.keys(this._config.breakpoints).sort((a, b) => parseInt(this._config.breakpoints[a]) - parseInt(this._config.breakpoints[b]));\n      const currentIndex = sortedBreakpoints.indexOf(currentBreakpoint);\n      for (let i = 0; i <= currentIndex; i++) {\n        const breakpoint = sortedBreakpoints[i];\n        if (mediaStyles[breakpoint]) {\n          Object.assign(responsiveStyle, mediaStyles[breakpoint]);\n        }\n      }\n    }\n    // Remove the @media property as it's not a valid CSS property\n    delete responsiveStyle['@media'];\n    return responsiveStyle;\n  }\n  // Create responsive styles\n  createResponsiveStyles(baseStyles, responsiveStyles) {\n    return {\n      ...baseStyles,\n      '@media': responsiveStyles\n    };\n  }\n  // Listen for breakpoint changes\n  onBreakpointChange(callback) {\n    const handleChange = () => {\n      callback(this.getCurrentBreakpoint());\n    };\n    // Add listeners to all media queries\n    this._mediaQueries.forEach((mediaQuery, breakpoint) => {\n      const listener = e => {\n        if (e.matches) {\n          handleChange();\n        }\n      };\n      mediaQuery.addEventListener('change', listener);\n      this._listeners.set(breakpoint, listener);\n    });\n    // Return cleanup function\n    return () => {\n      this._mediaQueries.forEach((mediaQuery, breakpoint) => {\n        const listener = this._listeners.get(breakpoint);\n        if (listener) {\n          mediaQuery.removeEventListener('change', listener);\n          this._listeners.delete(breakpoint);\n        }\n      });\n    };\n  }\n  // Get breakpoint value\n  getBreakpointValue(breakpoint) {\n    return this._config.breakpoints[breakpoint];\n  }\n  // Get all breakpoints\n  getBreakpoints() {\n    return {\n      ...this._config.breakpoints\n    };\n  }\n  // Update configuration\n  updateConfig(newConfig) {\n    this._config = {\n      ...this._config,\n      ...newConfig\n    };\n    this._initializeMediaQueries();\n  }\n  // Check if a breakpoint exists\n  hasBreakpoint(breakpoint) {\n    return breakpoint in this._config.breakpoints;\n  }\n  // Add a new breakpoint\n  addBreakpoint(breakpoint, value) {\n    this._config.breakpoints[breakpoint] = value;\n    this._initializeMediaQueries();\n  }\n  // Remove a breakpoint\n  removeBreakpoint(breakpoint) {\n    delete this._config.breakpoints[breakpoint];\n    this._initializeMediaQueries();\n  }\n  // Get the next breakpoint\n  getNextBreakpoint(currentBreakpoint) {\n    const sortedBreakpoints = Object.keys(this._config.breakpoints).sort((a, b) => parseInt(this._config.breakpoints[a]) - parseInt(this._config.breakpoints[b]));\n    const currentIndex = sortedBreakpoints.indexOf(currentBreakpoint);\n    return currentIndex < sortedBreakpoints.length - 1 ? sortedBreakpoints[currentIndex + 1] : null;\n  }\n  // Get the previous breakpoint\n  getPreviousBreakpoint(currentBreakpoint) {\n    const sortedBreakpoints = Object.keys(this._config.breakpoints).sort((a, b) => parseInt(this._config.breakpoints[a]) - parseInt(this._config.breakpoints[b]));\n    const currentIndex = sortedBreakpoints.indexOf(currentBreakpoint);\n    return currentIndex > 0 ? sortedBreakpoints[currentIndex - 1] : null;\n  }\n}","map":{"version":3,"names":["QElementResponsiveManager","constructor","config","_mediaQueries","Map","_listeners","_config","breakpoints","sm","md","lg","xl","defaultBreakpoint","_initializeMediaQueries","Object","entries","forEach","breakpoint","value","mediaQuery","window","matchMedia","set","getCurrentBreakpoint","sortedBreakpoints","sort","a","b","parseInt","reverse","get","matches","isBreakpointActive","getResponsiveStyles","style","currentBreakpoint","responsiveStyle","mediaStyles","keys","currentIndex","indexOf","i","assign","createResponsiveStyles","baseStyles","responsiveStyles","onBreakpointChange","callback","handleChange","listener","e","addEventListener","removeEventListener","delete","getBreakpointValue","getBreakpoints","updateConfig","newConfig","hasBreakpoint","addBreakpoint","removeBreakpoint","getNextBreakpoint","length","getPreviousBreakpoint"],"sources":["/Users/jayson/Downloads/QElement/dist/QElementResponsive.js"],"sourcesContent":["export class QElementResponsiveManager {\n    constructor(config) {\n        this._mediaQueries = new Map();\n        this._listeners = new Map();\n        this._config = {\n            breakpoints: {\n                sm: '640px',\n                md: '768px',\n                lg: '1024px',\n                xl: '1280px',\n                '2xl': '1536px'\n            },\n            defaultBreakpoint: 'md',\n            ...config\n        };\n        this._initializeMediaQueries();\n    }\n    _initializeMediaQueries() {\n        Object.entries(this._config.breakpoints).forEach(([breakpoint, value]) => {\n            const mediaQuery = window.matchMedia(`(min-width: ${value})`);\n            this._mediaQueries.set(breakpoint, mediaQuery);\n        });\n    }\n    // Get the current active breakpoint\n    getCurrentBreakpoint() {\n        const sortedBreakpoints = Object.entries(this._config.breakpoints)\n            .sort(([, a], [, b]) => parseInt(a) - parseInt(b))\n            .reverse();\n        for (const [breakpoint, value] of sortedBreakpoints) {\n            const mediaQuery = this._mediaQueries.get(breakpoint);\n            if (mediaQuery && mediaQuery.matches) {\n                return breakpoint;\n            }\n        }\n        return 'sm'; // Default to smallest breakpoint\n    }\n    // Check if a breakpoint is currently active\n    isBreakpointActive(breakpoint) {\n        const mediaQuery = this._mediaQueries.get(breakpoint);\n        return mediaQuery ? mediaQuery.matches : false;\n    }\n    // Get responsive styles for the current breakpoint\n    getResponsiveStyles(style) {\n        const currentBreakpoint = this.getCurrentBreakpoint();\n        const responsiveStyle = { ...style };\n        // Apply media query styles\n        if (style['@media']) {\n            const mediaStyles = style['@media'];\n            // Apply styles for the current breakpoint and smaller ones\n            const sortedBreakpoints = Object.keys(this._config.breakpoints)\n                .sort((a, b) => parseInt(this._config.breakpoints[a]) - parseInt(this._config.breakpoints[b]));\n            const currentIndex = sortedBreakpoints.indexOf(currentBreakpoint);\n            for (let i = 0; i <= currentIndex; i++) {\n                const breakpoint = sortedBreakpoints[i];\n                if (mediaStyles[breakpoint]) {\n                    Object.assign(responsiveStyle, mediaStyles[breakpoint]);\n                }\n            }\n        }\n        // Remove the @media property as it's not a valid CSS property\n        delete responsiveStyle['@media'];\n        return responsiveStyle;\n    }\n    // Create responsive styles\n    createResponsiveStyles(baseStyles, responsiveStyles) {\n        return {\n            ...baseStyles,\n            '@media': responsiveStyles\n        };\n    }\n    // Listen for breakpoint changes\n    onBreakpointChange(callback) {\n        const handleChange = () => {\n            callback(this.getCurrentBreakpoint());\n        };\n        // Add listeners to all media queries\n        this._mediaQueries.forEach((mediaQuery, breakpoint) => {\n            const listener = (e) => {\n                if (e.matches) {\n                    handleChange();\n                }\n            };\n            mediaQuery.addEventListener('change', listener);\n            this._listeners.set(breakpoint, listener);\n        });\n        // Return cleanup function\n        return () => {\n            this._mediaQueries.forEach((mediaQuery, breakpoint) => {\n                const listener = this._listeners.get(breakpoint);\n                if (listener) {\n                    mediaQuery.removeEventListener('change', listener);\n                    this._listeners.delete(breakpoint);\n                }\n            });\n        };\n    }\n    // Get breakpoint value\n    getBreakpointValue(breakpoint) {\n        return this._config.breakpoints[breakpoint];\n    }\n    // Get all breakpoints\n    getBreakpoints() {\n        return { ...this._config.breakpoints };\n    }\n    // Update configuration\n    updateConfig(newConfig) {\n        this._config = { ...this._config, ...newConfig };\n        this._initializeMediaQueries();\n    }\n    // Check if a breakpoint exists\n    hasBreakpoint(breakpoint) {\n        return breakpoint in this._config.breakpoints;\n    }\n    // Add a new breakpoint\n    addBreakpoint(breakpoint, value) {\n        this._config.breakpoints[breakpoint] = value;\n        this._initializeMediaQueries();\n    }\n    // Remove a breakpoint\n    removeBreakpoint(breakpoint) {\n        delete this._config.breakpoints[breakpoint];\n        this._initializeMediaQueries();\n    }\n    // Get the next breakpoint\n    getNextBreakpoint(currentBreakpoint) {\n        const sortedBreakpoints = Object.keys(this._config.breakpoints)\n            .sort((a, b) => parseInt(this._config.breakpoints[a]) - parseInt(this._config.breakpoints[b]));\n        const currentIndex = sortedBreakpoints.indexOf(currentBreakpoint);\n        return currentIndex < sortedBreakpoints.length - 1 ? sortedBreakpoints[currentIndex + 1] : null;\n    }\n    // Get the previous breakpoint\n    getPreviousBreakpoint(currentBreakpoint) {\n        const sortedBreakpoints = Object.keys(this._config.breakpoints)\n            .sort((a, b) => parseInt(this._config.breakpoints[a]) - parseInt(this._config.breakpoints[b]));\n        const currentIndex = sortedBreakpoints.indexOf(currentBreakpoint);\n        return currentIndex > 0 ? sortedBreakpoints[currentIndex - 1] : null;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}