{"ast":null,"code":"import React, { useEffect, useRef, useMemo } from 'react';\nimport { useQElementAdvanced, useQElementResponsive, useQElementAnimation } from './QElementHooks';\nexport const QElementAdvanced = ({\n  elementId,\n  as: Component = 'div',\n  children,\n  className,\n  style: inlineStyle,\n  responsive,\n  animations,\n  onStyleChange,\n  onVisibilityChange,\n  onEnabledChange,\n  performanceMonitoring = false,\n  ...props\n}) => {\n  const {\n    element,\n    updateParent,\n    override,\n    reset,\n    getComputed,\n    validate,\n    isVisible,\n    isEnabled,\n    setVisible,\n    setEnabled,\n    addAnimation,\n    removeAnimation,\n    applyTheme,\n    createResponsiveStyles,\n    styleHash\n  } = useQElementAdvanced(elementId);\n  const {\n    currentBreakpoint,\n    isMobile,\n    isTablet,\n    isDesktop,\n    createResponsiveStyle\n  } = useQElementResponsive(elementId);\n  const {\n    animations: elementAnimations,\n    isAnimating,\n    addAnimation: addElementAnimation,\n    removeAnimation: removeElementAnimation,\n    playAnimation,\n    stopAnimation\n  } = useQElementAnimation(elementId);\n  const elementRef = useRef(null);\n  // Set up responsive styles\n  useEffect(() => {\n    if (responsive) {\n      createResponsiveStyle(responsive);\n    }\n  }, [responsive, createResponsiveStyle]);\n  // Set up animations\n  useEffect(() => {\n    if (animations) {\n      Object.entries(animations).forEach(([name, animation]) => {\n        addElementAnimation(name, animation);\n      });\n    }\n  }, [animations, addElementAnimation]);\n  // Convert QElement style to CSS style object\n  const convertToCSSStyle = qStyle => {\n    const cssStyle = {};\n    Object.entries(qStyle).forEach(([key, value]) => {\n      if (value !== undefined && value !== null) {\n        // Convert camelCase to kebab-case for CSS properties\n        const cssKey = key.replace(/([A-Z])/g, '-$1').toLowerCase();\n        cssStyle[cssKey] = value;\n      }\n    });\n    return cssStyle;\n  };\n  // Get computed style\n  const computedStyle = useMemo(() => {\n    const style = getComputed();\n    return style ? convertToCSSStyle(style) : {};\n  }, [getComputed, styleHash]);\n  // Merge computed style with inline style\n  const finalStyle = {\n    ...computedStyle,\n    ...inlineStyle,\n    // Add visibility and enabled states\n    display: isVisible ? computedStyle.display || 'block' : 'none',\n    pointerEvents: isEnabled ? 'auto' : 'none',\n    opacity: isEnabled ? 1 : 0.5\n  };\n  // Add animation styles\n  if (isAnimating && elementAnimations.length > 0) {\n    const animation = elementAnimations[0]; // Use first animation\n    finalStyle.animation = `${animation.name} ${animation.duration}ms ${animation.timingFunction}`;\n    if (animation.delay) finalStyle.animationDelay = `${animation.delay}ms`;\n    if (animation.iterationCount) finalStyle.animationIterationCount = animation.iterationCount.toString();\n    if (animation.direction) finalStyle.animationDirection = animation.direction;\n    if (animation.fillMode) finalStyle.animationFillMode = animation.fillMode;\n  }\n  // Performance monitoring\n  useEffect(() => {\n    if (performanceMonitoring) {\n      console.log(`QElement ${elementId} rendered with style hash: ${styleHash}`);\n    }\n  }, [elementId, styleHash, performanceMonitoring]);\n  // Style change callback\n  useEffect(() => {\n    if (onStyleChange) {\n      const style = getComputed();\n      if (style) {\n        onStyleChange(style);\n      }\n    }\n  }, [getComputed, onStyleChange, styleHash]);\n  // Visibility change callback\n  useEffect(() => {\n    if (onVisibilityChange) {\n      onVisibilityChange(isVisible);\n    }\n  }, [isVisible, onVisibilityChange]);\n  // Enabled change callback\n  useEffect(() => {\n    if (onEnabledChange) {\n      onEnabledChange(isEnabled);\n    }\n  }, [isEnabled, onEnabledChange]);\n  // Validation\n  const validation = validate();\n  if (!validation.isValid) {\n    console.warn(`QElement ${elementId} validation errors:`, validation.errors);\n  }\n  return React.createElement(Component, {\n    ref: elementRef,\n    className: className,\n    style: finalStyle,\n    'data-qelement-id': elementId,\n    'data-qelement-breakpoint': currentBreakpoint,\n    'data-qelement-visible': isVisible,\n    'data-qelement-enabled': isEnabled,\n    'data-qelement-animating': isAnimating,\n    ...props\n  }, children);\n};","map":{"version":3,"names":["React","useEffect","useRef","useMemo","useQElementAdvanced","useQElementResponsive","useQElementAnimation","QElementAdvanced","elementId","as","Component","children","className","style","inlineStyle","responsive","animations","onStyleChange","onVisibilityChange","onEnabledChange","performanceMonitoring","props","element","updateParent","override","reset","getComputed","validate","isVisible","isEnabled","setVisible","setEnabled","addAnimation","removeAnimation","applyTheme","createResponsiveStyles","styleHash","currentBreakpoint","isMobile","isTablet","isDesktop","createResponsiveStyle","elementAnimations","isAnimating","addElementAnimation","removeElementAnimation","playAnimation","stopAnimation","elementRef","Object","entries","forEach","name","animation","convertToCSSStyle","qStyle","cssStyle","key","value","undefined","cssKey","replace","toLowerCase","computedStyle","finalStyle","display","pointerEvents","opacity","length","duration","timingFunction","delay","animationDelay","iterationCount","animationIterationCount","toString","direction","animationDirection","fillMode","animationFillMode","console","log","validation","isValid","warn","errors","createElement","ref"],"sources":["/Users/jayson/Downloads/QElement/dist/QElementAdvanced.js"],"sourcesContent":["import React, { useEffect, useRef, useMemo } from 'react';\nimport { useQElementAdvanced, useQElementResponsive, useQElementAnimation } from './QElementHooks';\nexport const QElementAdvanced = ({ elementId, as: Component = 'div', children, className, style: inlineStyle, responsive, animations, onStyleChange, onVisibilityChange, onEnabledChange, performanceMonitoring = false, ...props }) => {\n    const { element, updateParent, override, reset, getComputed, validate, isVisible, isEnabled, setVisible, setEnabled, addAnimation, removeAnimation, applyTheme, createResponsiveStyles, styleHash } = useQElementAdvanced(elementId);\n    const { currentBreakpoint, isMobile, isTablet, isDesktop, createResponsiveStyle } = useQElementResponsive(elementId);\n    const { animations: elementAnimations, isAnimating, addAnimation: addElementAnimation, removeAnimation: removeElementAnimation, playAnimation, stopAnimation } = useQElementAnimation(elementId);\n    const elementRef = useRef(null);\n    // Set up responsive styles\n    useEffect(() => {\n        if (responsive) {\n            createResponsiveStyle(responsive);\n        }\n    }, [responsive, createResponsiveStyle]);\n    // Set up animations\n    useEffect(() => {\n        if (animations) {\n            Object.entries(animations).forEach(([name, animation]) => {\n                addElementAnimation(name, animation);\n            });\n        }\n    }, [animations, addElementAnimation]);\n    // Convert QElement style to CSS style object\n    const convertToCSSStyle = (qStyle) => {\n        const cssStyle = {};\n        Object.entries(qStyle).forEach(([key, value]) => {\n            if (value !== undefined && value !== null) {\n                // Convert camelCase to kebab-case for CSS properties\n                const cssKey = key.replace(/([A-Z])/g, '-$1').toLowerCase();\n                cssStyle[cssKey] = value;\n            }\n        });\n        return cssStyle;\n    };\n    // Get computed style\n    const computedStyle = useMemo(() => {\n        const style = getComputed();\n        return style ? convertToCSSStyle(style) : {};\n    }, [getComputed, styleHash]);\n    // Merge computed style with inline style\n    const finalStyle = {\n        ...computedStyle,\n        ...inlineStyle,\n        // Add visibility and enabled states\n        display: isVisible ? (computedStyle.display || 'block') : 'none',\n        pointerEvents: isEnabled ? 'auto' : 'none',\n        opacity: isEnabled ? 1 : 0.5\n    };\n    // Add animation styles\n    if (isAnimating && elementAnimations.length > 0) {\n        const animation = elementAnimations[0]; // Use first animation\n        finalStyle.animation = `${animation.name} ${animation.duration}ms ${animation.timingFunction}`;\n        if (animation.delay)\n            finalStyle.animationDelay = `${animation.delay}ms`;\n        if (animation.iterationCount)\n            finalStyle.animationIterationCount = animation.iterationCount.toString();\n        if (animation.direction)\n            finalStyle.animationDirection = animation.direction;\n        if (animation.fillMode)\n            finalStyle.animationFillMode = animation.fillMode;\n    }\n    // Performance monitoring\n    useEffect(() => {\n        if (performanceMonitoring) {\n            console.log(`QElement ${elementId} rendered with style hash: ${styleHash}`);\n        }\n    }, [elementId, styleHash, performanceMonitoring]);\n    // Style change callback\n    useEffect(() => {\n        if (onStyleChange) {\n            const style = getComputed();\n            if (style) {\n                onStyleChange(style);\n            }\n        }\n    }, [getComputed, onStyleChange, styleHash]);\n    // Visibility change callback\n    useEffect(() => {\n        if (onVisibilityChange) {\n            onVisibilityChange(isVisible);\n        }\n    }, [isVisible, onVisibilityChange]);\n    // Enabled change callback\n    useEffect(() => {\n        if (onEnabledChange) {\n            onEnabledChange(isEnabled);\n        }\n    }, [isEnabled, onEnabledChange]);\n    // Validation\n    const validation = validate();\n    if (!validation.isValid) {\n        console.warn(`QElement ${elementId} validation errors:`, validation.errors);\n    }\n    return React.createElement(Component, {\n        ref: elementRef,\n        className: className,\n        style: finalStyle,\n        'data-qelement-id': elementId,\n        'data-qelement-breakpoint': currentBreakpoint,\n        'data-qelement-visible': isVisible,\n        'data-qelement-enabled': isEnabled,\n        'data-qelement-animating': isAnimating,\n        ...props\n    }, children);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}