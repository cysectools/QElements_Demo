{"ast":null,"code":"export class QElementResponsiveManager {\n  constructor(config) {\n    this._config = void 0;\n    this._mediaQueries = new Map();\n    this._listeners = new Map();\n    this._config = {\n      breakpoints: {\n        sm: '640px',\n        md: '768px',\n        lg: '1024px',\n        xl: '1280px',\n        '2xl': '1536px'\n      },\n      defaultBreakpoint: 'md',\n      ...config\n    };\n    this._initializeMediaQueries();\n  }\n  _initializeMediaQueries() {\n    Object.entries(this._config.breakpoints).forEach(([breakpoint, value]) => {\n      const mediaQuery = window.matchMedia(`(min-width: ${value})`);\n      this._mediaQueries.set(breakpoint, mediaQuery);\n    });\n  }\n\n  // Get the current active breakpoint\n  getCurrentBreakpoint() {\n    const sortedBreakpoints = Object.entries(this._config.breakpoints).sort(([, a], [, b]) => parseInt(a) - parseInt(b)).reverse();\n    for (const [breakpoint, value] of sortedBreakpoints) {\n      const mediaQuery = this._mediaQueries.get(breakpoint);\n      if (mediaQuery && mediaQuery.matches) {\n        return breakpoint;\n      }\n    }\n    return 'sm'; // Default to smallest breakpoint\n  }\n\n  // Check if a breakpoint is currently active\n  isBreakpointActive(breakpoint) {\n    const mediaQuery = this._mediaQueries.get(breakpoint);\n    return mediaQuery ? mediaQuery.matches : false;\n  }\n\n  // Get responsive styles for the current breakpoint\n  getResponsiveStyles(style) {\n    const currentBreakpoint = this.getCurrentBreakpoint();\n    const responsiveStyle = {\n      ...style\n    };\n\n    // Apply media query styles\n    if (style['@media']) {\n      const mediaStyles = style['@media'];\n\n      // Apply styles for the current breakpoint and smaller ones\n      const sortedBreakpoints = Object.keys(this._config.breakpoints).sort((a, b) => parseInt(this._config.breakpoints[a]) - parseInt(this._config.breakpoints[b]));\n      const currentIndex = sortedBreakpoints.indexOf(currentBreakpoint);\n      for (let i = 0; i <= currentIndex; i++) {\n        const breakpoint = sortedBreakpoints[i];\n        if (mediaStyles[breakpoint]) {\n          Object.assign(responsiveStyle, mediaStyles[breakpoint]);\n        }\n      }\n    }\n\n    // Remove the @media property as it's not a valid CSS property\n    delete responsiveStyle['@media'];\n    return responsiveStyle;\n  }\n\n  // Create responsive styles\n  createResponsiveStyles(baseStyles, responsiveStyles) {\n    return {\n      ...baseStyles,\n      '@media': responsiveStyles\n    };\n  }\n\n  // Listen for breakpoint changes\n  onBreakpointChange(callback) {\n    const handleChange = () => {\n      callback(this.getCurrentBreakpoint());\n    };\n\n    // Add listeners to all media queries\n    this._mediaQueries.forEach((mediaQuery, breakpoint) => {\n      const listener = e => {\n        if (e.matches) {\n          handleChange();\n        }\n      };\n      mediaQuery.addEventListener('change', listener);\n      this._listeners.set(breakpoint, listener);\n    });\n\n    // Return cleanup function\n    return () => {\n      this._mediaQueries.forEach((mediaQuery, breakpoint) => {\n        const listener = this._listeners.get(breakpoint);\n        if (listener) {\n          mediaQuery.removeEventListener('change', listener);\n          this._listeners.delete(breakpoint);\n        }\n      });\n    };\n  }\n\n  // Get breakpoint value\n  getBreakpointValue(breakpoint) {\n    return this._config.breakpoints[breakpoint];\n  }\n\n  // Get all breakpoints\n  getBreakpoints() {\n    return {\n      ...this._config.breakpoints\n    };\n  }\n\n  // Update configuration\n  updateConfig(newConfig) {\n    this._config = {\n      ...this._config,\n      ...newConfig\n    };\n    this._initializeMediaQueries();\n  }\n\n  // Check if a breakpoint exists\n  hasBreakpoint(breakpoint) {\n    return breakpoint in this._config.breakpoints;\n  }\n\n  // Add a new breakpoint\n  addBreakpoint(breakpoint, value) {\n    this._config.breakpoints[breakpoint] = value;\n    this._initializeMediaQueries();\n  }\n\n  // Remove a breakpoint\n  removeBreakpoint(breakpoint) {\n    delete this._config.breakpoints[breakpoint];\n    this._initializeMediaQueries();\n  }\n\n  // Get the next breakpoint\n  getNextBreakpoint(currentBreakpoint) {\n    const sortedBreakpoints = Object.keys(this._config.breakpoints).sort((a, b) => parseInt(this._config.breakpoints[a]) - parseInt(this._config.breakpoints[b]));\n    const currentIndex = sortedBreakpoints.indexOf(currentBreakpoint);\n    return currentIndex < sortedBreakpoints.length - 1 ? sortedBreakpoints[currentIndex + 1] : null;\n  }\n\n  // Get the previous breakpoint\n  getPreviousBreakpoint(currentBreakpoint) {\n    const sortedBreakpoints = Object.keys(this._config.breakpoints).sort((a, b) => parseInt(this._config.breakpoints[a]) - parseInt(this._config.breakpoints[b]));\n    const currentIndex = sortedBreakpoints.indexOf(currentBreakpoint);\n    return currentIndex > 0 ? sortedBreakpoints[currentIndex - 1] : null;\n  }\n}","map":{"version":3,"names":["QElementResponsiveManager","constructor","config","_config","_mediaQueries","Map","_listeners","breakpoints","sm","md","lg","xl","defaultBreakpoint","_initializeMediaQueries","Object","entries","forEach","breakpoint","value","mediaQuery","window","matchMedia","set","getCurrentBreakpoint","sortedBreakpoints","sort","a","b","parseInt","reverse","get","matches","isBreakpointActive","getResponsiveStyles","style","currentBreakpoint","responsiveStyle","mediaStyles","keys","currentIndex","indexOf","i","assign","createResponsiveStyles","baseStyles","responsiveStyles","onBreakpointChange","callback","handleChange","listener","e","addEventListener","removeEventListener","delete","getBreakpointValue","getBreakpoints","updateConfig","newConfig","hasBreakpoint","addBreakpoint","removeBreakpoint","getNextBreakpoint","length","getPreviousBreakpoint"],"sources":["/Users/jayson/Downloads/QElements_Demo/src/qelements/QElementResponsive.ts"],"sourcesContent":["import { QElementStyle, QElementResponsiveConfig } from './types';\n\nexport class QElementResponsiveManager {\n  private _config: QElementResponsiveConfig;\n  private _mediaQueries: Map<string, MediaQueryList> = new Map();\n  private _listeners: Map<string, (e: MediaQueryListEvent) => void> = new Map();\n\n  constructor(config?: Partial<QElementResponsiveConfig>) {\n    this._config = {\n      breakpoints: {\n        sm: '640px',\n        md: '768px',\n        lg: '1024px',\n        xl: '1280px',\n        '2xl': '1536px'\n      },\n      defaultBreakpoint: 'md',\n      ...config\n    };\n\n    this._initializeMediaQueries();\n  }\n\n  private _initializeMediaQueries(): void {\n    Object.entries(this._config.breakpoints).forEach(([breakpoint, value]) => {\n      const mediaQuery = window.matchMedia(`(min-width: ${value})`);\n      this._mediaQueries.set(breakpoint, mediaQuery);\n    });\n  }\n\n  // Get the current active breakpoint\n  getCurrentBreakpoint(): string {\n    const sortedBreakpoints = Object.entries(this._config.breakpoints)\n      .sort(([, a], [, b]) => parseInt(a) - parseInt(b))\n      .reverse();\n\n    for (const [breakpoint, value] of sortedBreakpoints) {\n      const mediaQuery = this._mediaQueries.get(breakpoint);\n      if (mediaQuery && mediaQuery.matches) {\n        return breakpoint;\n      }\n    }\n\n    return 'sm'; // Default to smallest breakpoint\n  }\n\n  // Check if a breakpoint is currently active\n  isBreakpointActive(breakpoint: string): boolean {\n    const mediaQuery = this._mediaQueries.get(breakpoint);\n    return mediaQuery ? mediaQuery.matches : false;\n  }\n\n  // Get responsive styles for the current breakpoint\n  getResponsiveStyles(style: QElementStyle): QElementStyle {\n    const currentBreakpoint = this.getCurrentBreakpoint();\n    const responsiveStyle: QElementStyle = { ...style };\n\n    // Apply media query styles\n    if (style['@media']) {\n      const mediaStyles = style['@media'];\n      \n      // Apply styles for the current breakpoint and smaller ones\n      const sortedBreakpoints = Object.keys(this._config.breakpoints)\n        .sort((a, b) => parseInt(this._config.breakpoints[a]) - parseInt(this._config.breakpoints[b]));\n\n      const currentIndex = sortedBreakpoints.indexOf(currentBreakpoint);\n      \n      for (let i = 0; i <= currentIndex; i++) {\n        const breakpoint = sortedBreakpoints[i];\n        if (mediaStyles[breakpoint]) {\n          Object.assign(responsiveStyle, mediaStyles[breakpoint]);\n        }\n      }\n    }\n\n    // Remove the @media property as it's not a valid CSS property\n    delete responsiveStyle['@media'];\n\n    return responsiveStyle;\n  }\n\n  // Create responsive styles\n  createResponsiveStyles(baseStyles: QElementStyle, responsiveStyles: {\n    [breakpoint: string]: Partial<QElementStyle>;\n  }): QElementStyle {\n    return {\n      ...baseStyles,\n      '@media': responsiveStyles\n    };\n  }\n\n  // Listen for breakpoint changes\n  onBreakpointChange(callback: (breakpoint: string) => void): () => void {\n    const handleChange = () => {\n      callback(this.getCurrentBreakpoint());\n    };\n\n    // Add listeners to all media queries\n    this._mediaQueries.forEach((mediaQuery, breakpoint) => {\n      const listener = (e: MediaQueryListEvent) => {\n        if (e.matches) {\n          handleChange();\n        }\n      };\n      \n      mediaQuery.addEventListener('change', listener);\n      this._listeners.set(breakpoint, listener);\n    });\n\n    // Return cleanup function\n    return () => {\n      this._mediaQueries.forEach((mediaQuery, breakpoint) => {\n        const listener = this._listeners.get(breakpoint);\n        if (listener) {\n          mediaQuery.removeEventListener('change', listener);\n          this._listeners.delete(breakpoint);\n        }\n      });\n    };\n  }\n\n  // Get breakpoint value\n  getBreakpointValue(breakpoint: string): string | undefined {\n    return this._config.breakpoints[breakpoint];\n  }\n\n  // Get all breakpoints\n  getBreakpoints(): { [key: string]: string } {\n    return { ...this._config.breakpoints };\n  }\n\n  // Update configuration\n  updateConfig(newConfig: Partial<QElementResponsiveConfig>): void {\n    this._config = { ...this._config, ...newConfig };\n    this._initializeMediaQueries();\n  }\n\n  // Check if a breakpoint exists\n  hasBreakpoint(breakpoint: string): boolean {\n    return breakpoint in this._config.breakpoints;\n  }\n\n  // Add a new breakpoint\n  addBreakpoint(breakpoint: string, value: string): void {\n    this._config.breakpoints[breakpoint] = value;\n    this._initializeMediaQueries();\n  }\n\n  // Remove a breakpoint\n  removeBreakpoint(breakpoint: string): void {\n    delete this._config.breakpoints[breakpoint];\n    this._initializeMediaQueries();\n  }\n\n  // Get the next breakpoint\n  getNextBreakpoint(currentBreakpoint: string): string | null {\n    const sortedBreakpoints = Object.keys(this._config.breakpoints)\n      .sort((a, b) => parseInt(this._config.breakpoints[a]) - parseInt(this._config.breakpoints[b]));\n    \n    const currentIndex = sortedBreakpoints.indexOf(currentBreakpoint);\n    return currentIndex < sortedBreakpoints.length - 1 ? sortedBreakpoints[currentIndex + 1] : null;\n  }\n\n  // Get the previous breakpoint\n  getPreviousBreakpoint(currentBreakpoint: string): string | null {\n    const sortedBreakpoints = Object.keys(this._config.breakpoints)\n      .sort((a, b) => parseInt(this._config.breakpoints[a]) - parseInt(this._config.breakpoints[b]));\n    \n    const currentIndex = sortedBreakpoints.indexOf(currentBreakpoint);\n    return currentIndex > 0 ? sortedBreakpoints[currentIndex - 1] : null;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}